// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package watcher

import (
	"context"
	"github.com/go-kratos/kratos/v2/log"
	"gopkg.in/alexcesaro/statsd.v2"
	"sync"
)

// Ensure, that loggerMock does implement logger.
// If this is not the case, regenerate this file with moq.
var _ logger = &loggerMock{}

// loggerMock is a mock implementation of logger.
//
//	func TestSomethingThatUseslogger(t *testing.T) {
//
//		// make and configure a mocked logger
//		mockedlogger := &loggerMock{
//			WithContextFunc: func(ctx context.Context) *log.Helper {
//				panic("mock out the WithContext method")
//			},
//		}
//
//		// use mockedlogger in code that requires logger
//		// and then make assertions.
//
//	}
type loggerMock struct {
	// WithContextFunc mocks the WithContext method.
	WithContextFunc func(ctx context.Context) *log.Helper

	// calls tracks calls to the methods.
	calls struct {
		// WithContext holds details about calls to the WithContext method.
		WithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockWithContext sync.RWMutex
}

// WithContext calls WithContextFunc.
func (mock *loggerMock) WithContext(ctx context.Context) *log.Helper {
	if mock.WithContextFunc == nil {
		panic("loggerMock.WithContextFunc: method is nil but logger.WithContext was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockWithContext.Lock()
	mock.calls.WithContext = append(mock.calls.WithContext, callInfo)
	mock.lockWithContext.Unlock()
	return mock.WithContextFunc(ctx)
}

// WithContextCalls gets all the calls that were made to WithContext.
// Check the length with:
//
//	len(mockedlogger.WithContextCalls())
func (mock *loggerMock) WithContextCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockWithContext.RLock()
	calls = mock.calls.WithContext
	mock.lockWithContext.RUnlock()
	return calls
}

// Ensure, that baseLoggerMock does implement baseLogger.
// If this is not the case, regenerate this file with moq.
var _ baseLogger = &baseLoggerMock{}

// baseLoggerMock is a mock implementation of baseLogger.
//
//	func TestSomethingThatUsesbaseLogger(t *testing.T) {
//
//		// make and configure a mocked baseLogger
//		mockedbaseLogger := &baseLoggerMock{
//			LogFunc: func(level log.Level, keyvals ...interface{}) error {
//				panic("mock out the Log method")
//			},
//		}
//
//		// use mockedbaseLogger in code that requires baseLogger
//		// and then make assertions.
//
//	}
type baseLoggerMock struct {
	// LogFunc mocks the Log method.
	LogFunc func(level log.Level, keyvals ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Log holds details about calls to the Log method.
		Log []struct {
			// Level is the level argument value.
			Level log.Level
			// Keyvals is the keyvals argument value.
			Keyvals []interface{}
		}
	}
	lockLog sync.RWMutex
}

// Log calls LogFunc.
func (mock *baseLoggerMock) Log(level log.Level, keyvals ...interface{}) error {
	if mock.LogFunc == nil {
		panic("baseLoggerMock.LogFunc: method is nil but baseLogger.Log was just called")
	}
	callInfo := struct {
		Level   log.Level
		Keyvals []interface{}
	}{
		Level:   level,
		Keyvals: keyvals,
	}
	mock.lockLog.Lock()
	mock.calls.Log = append(mock.calls.Log, callInfo)
	mock.lockLog.Unlock()
	return mock.LogFunc(level, keyvals...)
}

// LogCalls gets all the calls that were made to Log.
// Check the length with:
//
//	len(mockedbaseLogger.LogCalls())
func (mock *baseLoggerMock) LogCalls() []struct {
	Level   log.Level
	Keyvals []interface{}
} {
	var calls []struct {
		Level   log.Level
		Keyvals []interface{}
	}
	mock.lockLog.RLock()
	calls = mock.calls.Log
	mock.lockLog.RUnlock()
	return calls
}

// Ensure, that metricsMock does implement metrics.
// If this is not the case, regenerate this file with moq.
var _ metrics = &metricsMock{}

// metricsMock is a mock implementation of metrics.
//
//	func TestSomethingThatUsesmetrics(t *testing.T) {
//
//		// make and configure a mocked metrics
//		mockedmetrics := &metricsMock{
//			IncrementFunc: func(bucket string)  {
//				panic("mock out the Increment method")
//			},
//			NewTimingFunc: func() statsd.Timing {
//				panic("mock out the NewTiming method")
//			},
//		}
//
//		// use mockedmetrics in code that requires metrics
//		// and then make assertions.
//
//	}
type metricsMock struct {
	// IncrementFunc mocks the Increment method.
	IncrementFunc func(bucket string)

	// NewTimingFunc mocks the NewTiming method.
	NewTimingFunc func() statsd.Timing

	// calls tracks calls to the methods.
	calls struct {
		// Increment holds details about calls to the Increment method.
		Increment []struct {
			// Bucket is the bucket argument value.
			Bucket string
		}
		// NewTiming holds details about calls to the NewTiming method.
		NewTiming []struct {
		}
	}
	lockIncrement sync.RWMutex
	lockNewTiming sync.RWMutex
}

// Increment calls IncrementFunc.
func (mock *metricsMock) Increment(bucket string) {
	if mock.IncrementFunc == nil {
		panic("metricsMock.IncrementFunc: method is nil but metrics.Increment was just called")
	}
	callInfo := struct {
		Bucket string
	}{
		Bucket: bucket,
	}
	mock.lockIncrement.Lock()
	mock.calls.Increment = append(mock.calls.Increment, callInfo)
	mock.lockIncrement.Unlock()
	mock.IncrementFunc(bucket)
}

// IncrementCalls gets all the calls that were made to Increment.
// Check the length with:
//
//	len(mockedmetrics.IncrementCalls())
func (mock *metricsMock) IncrementCalls() []struct {
	Bucket string
} {
	var calls []struct {
		Bucket string
	}
	mock.lockIncrement.RLock()
	calls = mock.calls.Increment
	mock.lockIncrement.RUnlock()
	return calls
}

// NewTiming calls NewTimingFunc.
func (mock *metricsMock) NewTiming() statsd.Timing {
	if mock.NewTimingFunc == nil {
		panic("metricsMock.NewTimingFunc: method is nil but metrics.NewTiming was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNewTiming.Lock()
	mock.calls.NewTiming = append(mock.calls.NewTiming, callInfo)
	mock.lockNewTiming.Unlock()
	return mock.NewTimingFunc()
}

// NewTimingCalls gets all the calls that were made to NewTiming.
// Check the length with:
//
//	len(mockedmetrics.NewTimingCalls())
func (mock *metricsMock) NewTimingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNewTiming.RLock()
	calls = mock.calls.NewTiming
	mock.lockNewTiming.RUnlock()
	return calls
}
